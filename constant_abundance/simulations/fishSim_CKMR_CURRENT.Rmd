---
title: "fishSim_CKMR"
output: html_document
---

```{r setup, include=FALSE}
#Setting global defaults for knitting -- can be overwritten in individual chunks
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```


### Define simulation parameters
Max age: two options: 
37 from https://www.saveourseasmagazine.com/lemon-sharks-old/
25 from White et. al. 2014
Juvenile survival values from Dibattista 2007: 0.55 (mort = 0.45)
Adult survival value from White et. al. 2014: 0.85 (mort=0.15)
Litter size from Feldheim et. al. 2002 (avg=6, max=18)
Age-at-maturity from Brown and Gruber 1988 (11.6 for M, 12.7 for F)
About 77 juvenile lemon sharks inhabit the nursery at a given time (White et al 2014).

```{r}
library(fishSim)
library(parallel)
library(doParallel)
library(foreach)
library(plyr) #for frequencies
library(optimx)
library(dplyr)

#From CKMR script#
t_start = 40
t_end = 45

# set up the simulation parameters
sim_yrs = c(1:39)
n_samp_yr = t_end-t_start #Number of years being sampled
n_samples_per_yr = 40
n_samples_total <- n_samples_per_yr * n_samp_yr + n_samples_per_yr #because sampling starts in year t_start, we need to add one more year

#makeFounder parameters
osr <- c(0.5, 0.5) #Operating sex ratio
stocks <- c() #stocks (empty for now)
maxAge <- 25 #max age of lemon sharks
Surv_age <- rep(0.85,maxAge) #Set survival for each age to 85%
Surv_age[1] <- 0.55 #Set survival for first year to 55%
Surv_age[2] <- 0.65 #Set survival for second year to 65%
Prop_age <- rep(1:maxAge)
pop <- 2000

for(iage in 2:maxAge)Prop_age[iage]=Prop_age[iage-1]*Surv_age[iage-1]
Prop_age <- Prop_age/sum(Prop_age)  #stable age distribution
survCurv <- Prop_age #Sets probability of founder cohort belonging to each age class

#Set parameters for altMate
batchSize = 6 #average size of brood -- assumes Poisson distribution for fecundity (which is default for altMate)
mat_m <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_m[12:maxAge]=1  #Knife-edge maturity for males, beginning at age 12

mat_f <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_f[13:maxAge]=1  #Knife-edge maturity for females, beginning at age 13

maleCurve <- c(mat_m, rep(max(mat_m), 1000)) #Set male age at maturity
femaleCurve <- c(mat_f, rep(max(mat_m), 1000)) #Set female age at maturity
maxClutch <- 18 #Maximum number of offspring one individual can possibly produce
mat_type <- "ageSex"

#Set parameters for mort()
ageMort <- (1 - Surv_age)
ageMort[maxAge+1] <- ageMort[maxAge]
death_type <- "age"
```

###Make Founder population and simulate into the future
```{r}
#makeFounders creates a matrix of specified size (pop) where each row is an individual in the founder popualtion.
indiv <- makeFounders(pop = pop, osr = osr, stocks = c(1), maxAge = maxAge, survCurv=survCurv)
head(indiv)
hist(as.numeric(indiv[,8])) #histogram of population ages

#Simulate 40 years of mating
#altMate derives the number of offspring produced by drawing from a sampling distribution for each female based on the parameters specified in the function. Fathers are randomly drawn from all mature males in the mother's stock.
##This loop takes ~ 1 minute to run
for (y in 1:length(sim_yrs)) {
  indiv <- altMate(indiv, batchSize = batchSize, fecundityDist = "poisson", year = y, type = mat_type, maxClutch = maxClutch, singlePaternity = FALSE, maleCurve = maleCurve, femaleCurve = femaleCurve)
  indiv <- mort(indiv, type = death_type, year=y, maxAge = maxAge, ageMort = ageMort) #make maxPop ~ 9000 if setting mort to flat, as this is the approx size of the population in the Bravington script.
  indiv <- birthdays(indiv)
}
nrow(indiv[is.na(indiv[,6]),]) ## the currently-alive population size.
```

### Sampling
Simulates six more years of population growth, sampling 40 individuals each year.
```{r}
#Repeats the above loop, assigning offspring, deaths, and birthdays, but this time also draws samples each year and records which animals were sampled in indiv
for (y in c(t_start:t_end)) {
  indiv <- altMate(indiv, batchSize = batchSize, fecundityDist = "poisson", year = y, type = mat_type, maxClutch = maxClutch, singlePaternity = FALSE, maleCurve = maleCurve, femaleCurve = femaleCurve)
  indiv <- mort(indiv, type = death_type, year=y, maxAge = maxAge, ageMort = ageMort)
  indiv <- birthdays(indiv)
  indiv <- capture(indiv, n=40, year = y, fatal = FALSE)
}
```

## Find relatives among sampled individuals
## findRelativesPar finds relatives among the sampled individuals and stores them in a large pairwise comparison dataframe where the columns are named with numeric code corresponding to the relationships shared between the individuals being compared.
```{r}
pairs <- findRelativesPar(indiv = indiv, sampled = TRUE)
POPs <- pairs[pairs$OneTwo == 1,1:2] ##Parent-Offspring pairs
#HSPs <- pairs[pairs$TwoTwo == 1,1:2] ##Half-Sibling pairs - IGNORE until we get POPs working
non_POPs <- pairs[pairs$OneTwo == 0,1:2] ##pairs that are not POPs
#non_HSPs <- pairs[pairs$TwoTwo == 0,1:2] ##pairs that are not half-sibs - IGNORE until we get POPs working

## Make the new dataframe for the adults
POPs_2 <- data.frame(matrix(ncol=4, nrow=0, dimnames = list(NULL, c("Adult_Birth","Adult_Capture_Year", "Offspring_Birth_Year", "Adult_Sex"))))

## First, determine which var is the adult.
## Then, look up that adult's information from the indiv dataframe. 
## Finally, store the adult's information to POPs_2.
for(i in 1:nrow(POPs)){
  if(indiv[indiv$Me == POPs$Var1[i],]$BirthY > indiv[indiv$Me == POPs$Var2[i],]$BirthY){
    POPs_2[i,1] <- indiv[indiv$Me == POPs$Var2[i],]$BirthY
    POPs_2[i,2] <- indiv[indiv$Me == POPs$Var2[i],]$SampY
    POPs_2[i,3] <- indiv[indiv$Me == POPs$Var1[i],]$BirthY
    POPs_2[i,4] <- indiv[indiv$Me == POPs$Var2[i],]$Sex
  }
  else{
    POPs_2[i,1] <- indiv[indiv$Me == POPs$Var1[i],]$BirthY
    POPs_2[i,2] <- indiv[indiv$Me == POPs$Var1[i],]$SampY
    POPs_2[i,3] <- indiv[indiv$Me == POPs$Var2[i],]$BirthY
    POPs_2[i,4] <- indiv[indiv$Me == POPs$Var1[i],]$Sex
  }
  i = i+1
}
#POPs_2

#Split new dataframe into mothers and fathers. (M=Male, F=Female)
POPs_M <- POPs_2[POPs_2$Adult_Sex == 'M',]
POPs_F <- POPs_2[POPs_2$Adult_Sex == 'F',]

#For Non-Pops
non_POPs_2 <- data.frame(matrix(ncol=4, nrow=0, dimnames = list(NULL, c("Adult_Birth","Adult_Capture_Year", "Offspring_Birth_Year", "Adult_Sex"))))

#indiv[indiv$Me == non_POPs$Var1[1],]$BirthY
#indiv[indiv$Me == non_POPs$Var1[2],]$BirthY
for(i in 1:nrow(non_POPs)){
  if(indiv[indiv$Me == non_POPs$Var1[i],]$BirthY > indiv[indiv$Me == non_POPs$Var2[i],]$BirthY){
    non_POPs_2[i,1] <- indiv[indiv$Me == non_POPs$Var2[i],]$BirthY
    non_POPs_2[i,2] <- indiv[indiv$Me == non_POPs$Var2[i],]$SampY
    non_POPs_2[i,3] <- indiv[indiv$Me == non_POPs$Var1[i],]$BirthY
    non_POPs_2[i,4] <- indiv[indiv$Me == non_POPs$Var2[i],]$Sex
  }
  else{
    non_POPs_2[i,1] <- indiv[indiv$Me == non_POPs$Var1[i],]$BirthY
    non_POPs_2[i,2] <- indiv[indiv$Me == non_POPs$Var1[i],]$SampY
    non_POPs_2[i,3] <- indiv[indiv$Me == non_POPs$Var2[i],]$BirthY
    non_POPs_2[i,4] <- indiv[indiv$Me == non_POPs$Var1[i],]$Sex
   }
  i = i+1
}

#Split new dataframe into mothers and fathers
non_POPs_M <- non_POPs_2[non_POPs_2$Adult_Sex == 'M',]
non_POPs_F <- non_POPs_2[non_POPs_2$Adult_Sex == 'F',]

POPs_F <- plyr::count(POPs_F[,1:3])
non_POPs_F <- plyr::count(non_POPs_F[,1:3])
POPs_M <- plyr::count(POPs_M[,1:3])
non_POPs_M <- plyr::count(non_POPs_M[,1:3])
```

Fit Model!
```{r}
m_truth <- nrow(indiv[is.na(indiv$DeathY)==TRUE & indiv$Sex=="M" & indiv$AgeLast >=12,])
f_truth <- nrow(indiv[is.na(indiv$DeathY)==TRUE & indiv$Sex=="F" & indiv$AgeLast >=13,])
Pars <- c(log(f_truth), log(m_truth))

##Define variables and functions
source("functions/get_P_Lemon_POP_sim.R")
source("functions/Lemon_neg_log_like_sim.R")

P = get_P_lemon(Pars=Pars,P_Mother=P_Mother,P_Father=P_Father,n_yrs=n_yrs,t_start=t_start,t_end=t_end)

#Check P function
#P$P_Mother[19,40,45] #Dimensions are parent birth year, parent capture year, offspring birth year (all of which are specified by n_yrs)

#Fit model
CK_fit <- optimx(par=Pars,fn=lemon_neg_log_lik,hessian=TRUE, method="BFGS", Negatives_Mother=non_POPs_F,Negatives_Father=non_POPs_M,Pairs_Mother=POPs_F,Pairs_Father=POPs_M,P_Mother=P_Mother,P_Father=P_Father,n_yrs=n_yrs,t_start=t_start,t_end=t_end)
    
    summary(CK_fit)
    #compute variance covariance matrix
    D=diag(length(Pars))*c(exp(CK_fit$p1[1]),exp(CK_fit$p2[1]), CK_fit$p3[1]) #derivatives of transformations
    VC_trans = solve(attr(CK_fit, "details")["BFGS" ,"nhatend"][[1]])
    VC = (t(D)%*%VC_trans%*%D) #delta method
    SE=sqrt(diag(VC))
    
    round(exp(CK_fit$p1[1]),0) #Nf
    round(SE[1],0) #NfSE
    round(exp(CK_fit$p2[1]),0) #Nm
    round(SE[2],0) #NmSE
```

Check that Var1 and Var2 are already organized by age
```{r}
for(i in 1:nrow(non_POPs)){
    non_POPs_2[i,1] <- indiv[indiv$Me == non_POPs$Var1[i],]$BirthY
    non_POPs_2[i,2] <- indiv[indiv$Me == non_POPs$Var1[i],]$SampY
    non_POPs_2[i,3] <- indiv[indiv$Me == non_POPs$Var2[i],]$BirthY
    non_POPs_2[i,4] <- indiv[indiv$Me == non_POPs$Var1[i],]$Sex  
}

colnames(non_POPs_2)[1:2] <- c("Var2_age", "Var1_age")
head(non_POPs)
  head(non_POPs_2)
nrow(non_POPs_2)  

length(which(non_POPs_2$Var1_age <= non_POPs_2$Var2_age))
length(which(non_POPs_2$Var1_age > non_POPs_2$Var2_age))
```