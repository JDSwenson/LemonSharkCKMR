---
title: "fishSim_CKMR"
output: html_document
---

```{r setup, include=FALSE}
#Setting global defaults for knitting -- can be overwritten in individual chunks
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```


### Define simulation parameters
Max age: two options: 
37 from https://www.saveourseasmagazine.com/lemon-sharks-old/
25 from White et. al. 2014
Juvenile survival values from Dibattista 2007: 0.55 (mort = 0.45)
Adult survival value from White et. al. 2014: 0.85 (mort=0.15)
Litter size from Feldheim et. al. 2002 (avg=6, max=18)
Age-at-maturity from Brown and Gruber 1988 (11.6 for M, 12.7 for F)
About 77 juvenile lemon sharks inhabit the nursery at a given time (White et al 2014).

```{r}
library(fishSim)
library(parallel)
library(doParallel)
library(foreach)
library(plyr) #for frequencies
library(optimx)
library(dplyr)

#From CKMR script#
t_start = 40
t_end = 45

# set up the simulation parameters
sim_yrs = c(1:39)
n_samp_yr = t_end-t_start #Number of years being sampled
n_samples_per_yr = 40
n_samples_total <- n_samples_per_yr * n_samp_yr + n_samples_per_yr #because sampling starts in year t_start, we need to add one more year


#makeFounder parameters
osr <- c(0.5, 0.5) #Operating sex ratio
stocks <- c() #stocks (empty for now)
maxAge <- 25 #max age of lemon sharks
Surv_age <- rep(0.85,maxAge) #Set survival for each age to 85%
Surv_age[1] <- 0.55 #Set survival for first year to 55%
Surv_age[2] <- 0.65 #Set survival for second year to 65%
Prop_age <- rep(1:maxAge)
pop <- 2000

for(iage in 2:maxAge)Prop_age[iage]=Prop_age[iage-1]*Surv_age[iage-1]
Prop_age <- Prop_age/sum(Prop_age)  #stable age distribution
survCurv <- Prop_age #Sets probability of founder cohort belonging to each age class

#Set parameters for altMate
batchSize = 6 #average size of brood -- assumes Poisson distribution for fecundity (which is default for altMate)
mat_m <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_m[12:maxAge]=1  #Knife-edge maturity for males, beginning at age 12

mat_f <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_f[13:maxAge]=1  #Knife-edge maturity for females, beginning at age 13

maleCurve <- c(mat_m, rep(max(mat_m), 1000)) #Set male age at maturity
femaleCurve <- c(mat_f, rep(max(mat_m), 1000)) #Set female age at maturity
maxClutch <- 18 #Maximum number of offspring one individual can possibly produce
mat_type <- "ageSex"

#Set parameters for mort()
ageMort <- (1 - Surv_age)
ageMort[maxAge+1] <- ageMort[maxAge]
death_type <- "age"
```

###Make Founder population and simulate into the future
```{r}
#makeFounders creates a matrix of specified size (pop) where each row is an individual in the founder popualtion.
indiv <- makeFounders(pop = pop, osr = osr, stocks = c(1), maxAge = maxAge, survCurv=survCurv)
head(indiv)
hist(as.numeric(indiv[,8])) #histogram of population ages

#Simulate 40 years of mating
#altMate derives the number of offspring produced by drawing from a sampling distribution for each female based on the parameters specified in the function. Fathers are randomly drawn from all mature males in the mother's stock.
##This loop takes ~ 1 minute to run
for (y in 1:length(sim_yrs)) {
  indiv <- altMate(indiv, batchSize = batchSize, fecundityDist = "poisson", year = y, type = mat_type, maxClutch = maxClutch, singlePaternity = FALSE, maleCurve = maleCurve, femaleCurve = femaleCurve)
  indiv <- mort(indiv, type = death_type, year=y, maxAge = maxAge, ageMort = ageMort) #make maxPop ~ 9000 if setting mort to flat, as this is the approx size of the population in the Bravington script.
  indiv <- birthdays(indiv)
}
nrow(indiv[is.na(indiv[,6]),]) ## the currently-alive population size.
```

### Sampling
Simulates six more years of population growth, sampling 40 individuals each year.
```{r}
#Repeats the above loop, assigning offspring, deaths, and birthdays, but this time also draws samples each year and records which animals were sampled in indiv
for (y in c(t_start:t_end)) {
  indiv <- altMate(indiv, batchSize = batchSize, fecundityDist = "poisson", year = y, type = mat_type, maxClutch = maxClutch, singlePaternity = FALSE, maleCurve = maleCurve, femaleCurve = femaleCurve)
  indiv <- mort(indiv, type = death_type, year=y, maxAge = maxAge, ageMort = ageMort)
  indiv <- birthdays(indiv)
  indiv <- capture(indiv, n=40, year = y, fatal = FALSE)
}
```

### Find relatives among sampled individuals
```{r}
## Find relatives among sampled individuals
## findRelativesPar finds relatives among the sampled individuals and stores them in a large pairwise comparison dataframe where the columns are named with numeric code corresponding to the relationships shared between the individuals being compared.
pairs <- findRelativesPar(indiv = indiv, sampled = TRUE)
POPs <- pairs[pairs$OneTwo == 1,1:2] ##Parent-Offspring pairs
HSPs <- pairs[pairs$TwoTwo == 1,1:2] ##Half-Sibling pairs
non_POPs <- pairs[pairs$OneTwo == 0,1:2] ##pairs that are not POPs
non_HSPs <- pairs[pairs$TwoTwo == 0,1:2] ##pairs that are not half-sibs
```


### Pairwise Comparison Matrix test code
```{r}
Data <- data.frame(matrix(0,nrow = n_samples_per_yr*(n_samples_per_yr-1)/2,ncol = 6))

#Fill in the array:
#Data[,1] = adult birth,
#Data[,2] = adult capture year
#Data[,3] = young birth
#Data[,4] = young capture year
#Data[,5] = adult sex

Data <- Data %>% rename('Adult_birth' = X1 , 'Adult_capture' = X2, 'Young_birth' = X3, 'Young_capture' = X4,'Adult_sex' = X5, 'Matches' = X6)

count = 1
for(iind1 in 1:(n_samples_total-1)){ #iind1 starts at 1 and counts to n_samples-1
  for(iind2 in (iind1+1):n_samples_total) { #iind2 starts at 2 and counts to n_samples
    if(total_df[iind1,5] > total_df[iind2,5]){
      #compare birth years of each combination of samples. If birth year is greater for iind1 i.e. if iind2 was born before iind1.
      Data[count,1] = total_df[iind2,5] #birth year of iind2 in Adult_birth
      Data[count,2] = total_df[iind2,10] #capture year of iind2 in Adult_capture
      Data[count,3] = total_df[iind1,5] #birth year of iind1 in Young_birth
      Data[count,4] = total_df[iind1,10] #capture year of young in Young_capture
      Data[count,5] = total_df[iind2,2] #sex of adult in Adult_sex
    }
    else{ #birth year greater for second value (or equal) - reverse above
      Data[count,1] = total_df[iind1,5]
      Data[count,2] = total_df[iind1,10]
      Data[count,3] = total_df[iind2,5]
      Data[count,4] = total_df[iind2,10]
      Data[count,5] = total_df[iind1,2]
    }
    count = count + 1
  }
}

head(Data)
tail(Data)
```


## CKMR script

#### Format pairwise comparison for CKMR #############################
## Ultimately, want four dataframes:
#1) Rows contain positive comparisons for mothers
#2) Rows contain positive comparisons for fathers
#3) Rows contain negative comparisons for mothers
#4) Rows contain negtive comparisons for fathers

```{r}
Data
dm <- Data[Data$Adult_Sex == "F",] #Subset pairwise matrix for mother comparisons
dd <- Data[Data$Adult_Sex == "M",] #Subset pairwise matrix for father comparisons

dm
#Count unique combos of adult birth, adult death, and offspring birth AND Master ID (should be the same)
dm2 <- plyr::count(dm[,c(1:3,6)])
dm2
dd2 <- plyr::count(dd[,c(1:3,6)])
colnames(dm2)[5] = colnames(dd2)[5] <- "No_matches" #Change frequency column to No_matches (assume for now all comparisons are no matches - will subtract matches later)
#head(dd2)

#Subset sampled moms and sampled dads from dataframe of all samples
#Sampled_Moms <- Samples[Samples$Mom == 1,] 
#Sampled_Dads <- Samples[Samples$Dad == 1,]
#View(Samples)

### Testing ###
Sampled_Moms <- total_df[total_df$Sex == 'F',] 
Sampled_Dads <- total_df[total_df$Sex == 'M',]

Sampled_Moms
#Create dataframe of sampled moms (sm) that includes a column that counts the occurrances of specific combinations of offspring birth, adult birth, and adult death



sm <- Sampled_Moms %>% 
  group_by(BirthY,DeathY) %>%  #ID which columns to group by
  summarise(Matches = sum(!is.na(Sampled_Moms)))

sm <- Sampled_Moms %>% 
  group_by(Birth, Mom_birth, Mom_capt) %>%  #ID which columns to group by
  summarise(Matches = sum(!is.na(Mom)))

sd <- Sampled_Dads %>% 
  group_by(Birth, Dad_birth, Dad_capt) %>%  #ID which columns to group by
  summarise(Matches = sum(!is.na(Dad)))
#Create dataframe of sampled dads (sd) that includes a column that counts the occurrances of specific combinations of offspring birth, adult birth, and adult death
# sd <- Sampled_Dads %>% 
#   group_by(Birth, Dad_birth, Dad_capt) %>%  #ID which columns to group by
#   summarise(Matches = sum(!is.na(Dad)))


#Create MasterID column to merge dataframes with matches (sm & sd) with dataframes with all comparisons (dm2, dd2)
sd$MasterID <- paste(sd$Dad_birth, sd$Dad_capt, sd$Birth, sep="-")
sm$MasterID <- paste(sm$Mom_birth, sm$Mom_capt, sm$Birth, sep="-")

all_dads <- merge(dd2, sd[,4:5], by="MasterID", all=TRUE) #Merge father dataframes
all_dads$Matches[is.na(all_dads$Matches)==TRUE] <- 0 #Put 0 in all Matches cells with NA
all_dads$No_matches <- all_dads$No_matches-all_dads$Matches #Subtract matches from no matches

#sum(all_dads$Matches)

all_moms <- merge(dm2, sm[,4:5], by="MasterID", all=TRUE) #Merge mother dataframes
all_moms$Matches[is.na(all_moms$Matches)==TRUE] <- 0 #Put 0 in all Matches cells with NA
all_moms$No_matches <- all_moms$No_matches-all_moms$Matches #Calculate number of no matches
```
##Define variables and functions
```{r}
source("functions/get_P_beluga_sim.R")
source("functions/beluga_neg_log_like_sim.R")

n_yrs=t_end
P_Mother = P_Father = array(0,dim=c(n_yrs,n_yrs,n_yrs))
P = get_P_beluga(Pars=Pars,P_Mother=P_Mother,P_Father=P_Father,Maturity_age=Maturity_age,n_yrs=n_yrs,t_start=t_start,t_end=t_end)

#Check P function
P$P_Mother[89,101,100] #mother born in year 89, died in year 101, gave birth to offspring in year 100
```
