---
title: "fishSim_CKMR"
output: html_document
---

```{r setup, include=FALSE}
#Setting global defaults for knitting -- can be overwritten in individual chunks
knitr::opts_chunk$set(echo = TRUE)
```

Goals as of 7/2/2019
- Fix line 123
- Change loop at line 207 to foreach

### Define beluga population parameters
```{r}
library(fishSim)
library(parallel)
library(doParallel)
library(foreach)
library(plyr) #for frequencies
library(optimx)

#From beluga CKMR script#
t_start = 100
t_end = 105

age_mat_male=8
n_ages=40 #max age of animal
logit<-function(x)log(x/(1-x))
Pars=c(log(4000),log(5000),logit(age_mat_male/n_ages),0)

Surv_age = rep(0.95,n_ages) #Set survival for each age to 95%
Surv_age[1]=0.85 #Set survival for first year to 85%
Prop_age = rep(1,n_ages)

Maturity_age = rep(0,n_ages) #creates an empty vector that has the length of n_ages
Maturity_age[12:n_ages]=1  #I *think* this says that animals 12 and older are always mature and have a probability of maturity of 1
Maturity_age[7:11] = c(1:5)/6

for(iage in 2:n_ages)Prop_age[iage]=Prop_age[iage-1]*Surv_age[iage-1]
Prop_age=Prop_age/sum(Prop_age)  #stable age distribution
```

###Make Founder population and simulate into the future
```{r}
indiv <- makeFounders(pop = 9000, osr = c(0.56, 0.44), stocks = c(1), maxAge = 40, survCurv=Prop_age)
head(indiv)
colnames(indiv) <- c("ID", "Sex", "Father.ID", "Mother.ID", "Birth.Year", "Death.Year", "Stock", "Age", "col_x") #unsure what column 9 is ...
ageMort <- c(.15, rep(.05, 1000))
hist(as.numeric(indiv[,8]))
nrow(indiv)
head(indiv)
tail(indiv)

sim_yrs = c(1:100)
for (y in 1:length(sim_yrs)) {
  indiv <- altMate(indiv, batchSize = .5, firstBreed = 0, fecundityDist = "binomial", year = y, type = "age", maxClutch = 1, singlePaternity = TRUE, maturityCurve = c(rep(0,6), 0.1666667, 0.3333333, 0.5, 0.6666667, 0.8333333, rep(1.0, 1000)))
  indiv <- mort(indiv, type = "simple", maxPop = 9000, year=y, maxAge = 40) #make maxPop ~ 9000 if setting mort to flat, as this is the approx size of the population in the Bravington script.
  indiv <- birthdays(indiv)
}

nrow(indiv[is.na(indiv[,6]),]) ## the currently-alive population size.
```

Find out how many adults are alive at t0 to compare to model estimates
```{r}
ncol(indiv)
indiv2 <- as.data.frame(indiv)
indiv2 <- indiv2[!is.na(indiv2$Death.Year),]

# Number of mature females alive at t0
cat(paste("Females alive at t0:", sum(as.numeric(as.character(indiv2$Age)) > as.numeric(as.character(indiv2$Death.Year)) & indiv2$Sex=="F")))

# Number of mature males alive at t0
cat(paste("Males alive at t0:", sum(as.numeric(as.character(indiv2$Age)) > as.numeric(as.character(indiv2$Death.Year)) & indiv2$Sex=="M")))
tail(indiv2)
```

### Sampling
## Simulates six more years of population growth, sampling 100 individuals each year. Grabs the birth year and sex of each individual from the indiv table, then manually gives a death year that corresponds to the year of sampling.
```{r}
head(indiv)
tail(indiv)

n_samp_yr = t_end-t_start #Number of years being sampled
n_samples_per_yr = 100
sample_vec <- c()
length(sample_vec)
for (y in c(t_start:t_end)) {
  indiv <- altMate(indiv, batchSize = .5, firstBreed = 0, fecundityDist = "binomial", year = y, type = "age", maxClutch = 1, singlePaternity = TRUE, maturityCurve = c(rep(0,6), 0.1666667, 0.3333333, 0.5, 0.6666667, 0.8333333, rep(1.0, 1000)))
  indiv <- mort(indiv, type = "simple", maxPop = 9000, year=y, maxAge = 40) #make maxPop ~ 9000 if setting mort to flat, as this is the approx size of the population in the Bravington script.
  indiv <- birthdays(indiv)
  sample_vec <- append(sample_vec, sample(indiv[indiv[,5] > (y-n_ages) & is.na(indiv[,6]) == TRUE,][,1], size = n_samples_per_yr))
  death_yr <- append(death_yr, rep(y, n_samples_per_yr))
}

head(sampled)
head(indiv)

length(sample_vec)
length(death_yr)
sampled <- cbind(sample_vec,death_yr) #make dataframe of sampled individuals and death year
sampled <- data.frame(sampled[duplicated(sampled[,1])==FALSE,]) #get rid of duplicate values

for(i in 1:length(sampled[,1])) {
  sampled[i,3] = as.numeric(indiv[which(indiv[,1] == sampled[i,1]),5]) #birth year
  sampled[i,4] = indiv[which(indiv[,1] == sampled[i,1]),2] #sex
}

sampled_col <- c("ID", "Death Year", "Birth Year", "Sex")
colnames(sampled) <- sampled_col
length(sampled[,1])
sampled <- sampled[,c(1,3,2,4)]
head(sampled)
tail(sampled)

sexnum <- c()
for(i in 1:length(sampled[,1])) {
  if(sampled[i,4] == "F") sexnum[i] = 0 else sexnum[i] = 1
}
sampled$sexnum <- sexnum
head(sampled)
tail(sampled)
```

###CKMR script
##Define variables and functions
```{r}
source("functions/get_P_beluga_sim.R")
source("functions/beluga_neg_log_like_sim.R")

n_yrs=t_end
P_Mother = P_Father = array(0,dim=c(n_yrs,n_yrs,n_yrs))
P = get_P_beluga(Pars=Pars,P_Mother=P_Mother,P_Father=P_Father,Maturity_age=Maturity_age,n_yrs=n_yrs,t_start=t_start,t_end=t_end)

#Check P function
P$P_Mother[89,101,100]
```

Find relatives among sampled individuals
```{r}
## Find relatives among sampled individuals
## This part takes awhile to run ...
pairs <- findRelativesPar(indiv = indiv, sampled = sampled[,1])
head(pairs)

HSPs <- pairs[pairs$TwoTwo == 1,] ##pairs that are half-siblings of each other
POPs <- pairs[pairs$OneTwo == 1,] ##pairs that are parents of each other
head(POPs)

POPs2 <- POPs[,1:2] #extract IDs from related individuals (for use in the next chunk)
length(POPs2[,1])
head(POPs2)

non_POPs <- pairs[pairs$OneTwo == 0,] ##pairs that are not related
non_POPs2 <- non_POPs[,1:2] #extract IDs from unrelated individuals (for use in the next chunk)
```

##Extract information for CKMR model
```{r}
#Related individuals
Data2 <- matrix(0, nrow = length(POPs2[,1]), ncol = 5)
#The For loop will return an error unless POPs2 and sampled have the same factor levels
POPs2[,1] <- factor(POPs2[,1], levels=levels(sampled[,1]))
POPs2[,2] <- factor(POPs2[,2], levels=levels(sampled[,1]))

for(i in 1:length(POPs2[,1])) { #extract data for CKMR for POPs from sampled individuals by comparing indiv IDs
  if(sampled[which(sampled[,1]==POPs2[i,1]),2] < sampled[which(sampled[,1]==POPs2[i,2]),2]) {
  Data2[i,1] = sampled[which(sampled[,1]==POPs2[i,1]),2]
  Data2[i,2] = sampled[which(sampled[,1]==POPs2[i,1]),3]
  Data2[i,3] = sampled[which(sampled[,1]==POPs2[i,2]),2]
  Data2[i,4] = sampled[which(sampled[,1]==POPs2[i,1]),5] #column 5 is numeric sex
  } else if(sampled[which(sampled[,1]==POPs2[i,1]),2] > sampled[which(sampled[,1]==POPs2[i,2]),2]) {
  Data2[i,1] = sampled[which(sampled[,1]==POPs2[i,2]),2]
  Data2[i,2] = sampled[which(sampled[,1]==POPs2[i,2]),3]
  Data2[i,3] = sampled[which(sampled[,1]==POPs2[i,1]),2]
  Data2[i,4] = sampled[which(sampled[,1]==POPs2[i,2]),5]
  }
}

head(Data2,12)
tail(Data2)
length(Data2[,1])
length(POPs2[,1])
length(POPs[,1])

######Unrelated individuals######
Data3 <- matrix(0, nrow = length(non_POPs2[,1]), ncol = 5)

#The For loop will return an error unless non_POPs2 and sampled have the same factor levels
non_POPs2[,1] <- factor(non_POPs2[,1], levels=levels(sampled[,1]))
non_POPs2[,2] <- factor(non_POPs2[,2], levels=levels(sampled[,1]))

#Should change the below loop to Foreach -- it runs really slow otherwise 6/17/2019
#start time 6:06 - end time 6:26 -- so 20 minutes
#extract data for CKMR for unrelated pairs from sampled individuals by comparing indiv IDs and the corresponding ages to determine which should be the parent and which the offspring. Intra-cohort samples (i.e. same age) are just included in the second half of the loop.

for(i in 1:length(non_POPs2[,1])) {
  if(sampled[which(sampled[,1]==non_POPs2[i,1]),2] < sampled[which(sampled[,1]==non_POPs2[i,2]),2]) {
  Data3[i,1] = sampled[which(sampled[,1]==non_POPs2[i,1]),2]
  Data3[i,2] = sampled[which(sampled[,1]==non_POPs2[i,1]),3]
  Data3[i,3] = sampled[which(sampled[,1]==non_POPs2[i,2]),2]
  Data3[i,4] = sampled[which(sampled[,1]==non_POPs2[i,1]),5] #column 5 is numeric sex
  } else if(sampled[which(sampled[,1]==non_POPs2[i,1]),2] > sampled[which(sampled[,1]==non_POPs2[i,2]),2] | sampled[which(sampled[,1]==non_POPs2[i,1]),2] == sampled[which(sampled[,1]==non_POPs2[i,2]),2]) {
  Data3[i,1] = sampled[which(sampled[,1]==non_POPs2[i,2]),2]
  Data3[i,2] = sampled[which(sampled[,1]==non_POPs2[i,2]),3]
  Data3[i,3] = sampled[which(sampled[,1]==non_POPs2[i,1]),2]
  Data3[i,4] = sampled[which(sampled[,1]==non_POPs2[i,2]),5]
  }
}

head(sampled)
head(Data3,12)
tail(Data3)
length(Data3[,1]) #Should be same as non_POPs2
length(non_POPs2[,1])
```

```{r}
#subset from Data columns 1:4 of the rows that meet the criteria of sex being father and probability of kinship being 0
#Data_dad_no[,1] = adult birth,
#Data_dad_no[,2] = adult death year
#Data_dad_no[,3] = young birth
#Data_dad_no[,4] = adult sex
Mom_POPs = data.frame(Data2[which(Data2[,4]==0),1:3])
Dad_POPs = data.frame(Data2[which(Data2[,4]==1),1:3])
Mom_nonPOPs = data.frame(Data3[which(Data3[,4]==0),1:3])
Dad_nonPOPs = data.frame(Data3[which(Data3[,4]==1),1:3])
colnames(Mom_POPs) = colnames(Dad_POPs) = colnames(Mom_nonPOPs) = colnames(Dad_nonPOPs) = c("parent birth", "parent death", "offspring birth")
head(Mom_POPs)
head(Dad_POPs)
head(Mom_nonPOPs)
length(Mom_nonPOPs[,1])
length(Dad_nonPOPs[,1])
length(Data3[,1])
sum(length(Mom_nonPOPs[,1]),length(Dad_nonPOPs[,1]))

length(which(Mom_nonPOPs[,3]==0))
length(which(Dad_nonPOPs[,3]==0))
length(which(Data3[,3]==0))

head(Data3)
head(Dad_nonPOPs)

class(Mom_POPs[,1])
class(Dad_POPs[,1]) #double-check that it's numeric

head(Data2)

Dad_POPs=count(Dad_POPs[,1:3])
Mom_POPs=count(Mom_POPs[,1:3])
Dad_nonPOPs=count(Dad_nonPOPs[,1:3])
Mom_nonPOPs=count(Mom_nonPOPs[,1:3])

head(Dad_POPs)
head(Mom_POPs)
head(Dad_nonPOPs)
tail(Dad_nonPOPs)

#Save dataframes as the names that the CKMR model uses
Data_dad_no = Dad_nonPOPs
Data_dad_yes = Dad_POPs #same as above except prob kinship is 1
Data_mom_no = Mom_nonPOPs
Data_mom_yes = Mom_POPs
```

Fit model!
```{r}
CK_fit <- optimx(par=Pars,fn=beluga_neg_log_lik,hessian=TRUE,method="BFGS",Negatives_Mother=Data_mom_no,Negatives_Father=Data_dad_no,Pairs_Mother=Data_mom_yes,Pairs_Father=Data_dad_yes,P_Mother=P_Mother,P_Father=P_Father,Maturity_age=Maturity_age,n_yrs=n_yrs,t_start=t_start,t_end=t_end)
CK_fit
save.image(file="CKMR_Sim2.RData") #When making this script into a loop, will need to change this to rename with each separate iteration

#compute variance covariance matrix 
D=diag(4)*c(exp(CK_fit$p1),exp(CK_fit$p2),n_ages*exp(CK_fit$p3)/(1+exp(CK_fit$p3))^2,0.01*exp(CK_fit$p4)/(1+exp(CK_fit$p4))^2) #derivatives of transformations
VC_trans = solve(attr(CK_fit, "details")["BFGS" ,"nhatend"][[1]])
VC = (t(D)%*%VC_trans%*%D) #delta method
SE=sqrt(diag(VC))
cat(paste("Estimated mature female abundance: ",exp(CK_fit$p1),", SE = ",SE[1],"\n"))
cat(paste("Estimated mature male abundance: ",exp(CK_fit$p2),", SE = ",SE[2],"\n"))
cat(paste("Estimated male age at maturity: ",n_ages*plogis(CK_fit$p3),", SE = ",SE[3],"\n"))
cat(paste("Estimated log-scale trend: ",0.01*plogis(CK_fit$p4)-0.005,", SE = ",SE[4],"\n"))
cat(paste("Real scale lambda: ",exp(0.01*plogis(CK_fit$p4)-0.005),"\n"))
```

### Reference/helpful scripts ###
## What's my population doing?
# `check_growthrate()` tells you how quickly your population is growing. `PoNG()` tells you what you need first-year survival to be, in order for your population to maintain a constant size

```{r}
#check_growthrate(mateType = "age", mortType = "age", ageMort = ageMort, batchSize = .209, firstBreed = 0, maxClutch = 1, maturityCurve = c(rep(0,6), 0.1666667, 0.3333333, 0.5, 0.6666667, 0.8333333, rep(1.0, 1000))) #These values may produce a stable population

#PoNG(mateType = "flat", mortType = "age", ageMort = ageMort, batchSize = 8, firstBreed = 12, maxClutch = 18)
```


Look up true relationships - not using right now
```{r}
## look at the number of shared ancestors at each ancestral
## generation, for one of the parent-offspring pairs.
pairs
(lookAtPair(POPs[1,]))

relatives <- namedRelatives(pairs) ## shows the number of pairs of each relationship type
relatives
#Set up Yes and No parentage matrices
```
