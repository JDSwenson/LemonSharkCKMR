---
title: "fishSim_CKMR"
output: html_document
---

```{r setup, include=FALSE}
#Setting global defaults for knitting -- can be overwritten in individual chunks
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```


### Define lemon population parameters
# Max age: two options: 
# 37 from https://www.saveourseasmagazine.com/lemon-sharks-old/
# 25 from White et. al. 2014
# Juvenile survival values from Dibattista 2007: 0.55 (mort = 0.45)
# Adult survival value from White et. al. 2014: 0.85 (mort=0.15)
# Litter size from Feldheim et. al. 2002 (avg=6, max=18)
# Age-at-maturity from Brown and Gruber 1988 (11.6 for M, 12.7 for F)
# About 77 juvenile lemon sharks inhabit the nursery at a given time (White et al 2014).

```{r}
library(fishSim)
library(parallel)
library(doParallel)
library(foreach)
library(plyr) #for frequencies
library(optimx)

#From CKMR script#
t_start = 40
t_end = 45

#makeFounder parameters
osr <- c(0.5, 0.5) #Operating sex ratio
stocks <- c() #stocks (empty for now)
maxAge <- 25 #max age of lemon sharks
Surv_age <- rep(0.85,maxAge) #Set survival for each age to 85%
Surv_age[1] <- 0.55 #Set survival for first year to 55%
Prop_age <- rep(1:maxAge)

for(iage in 2:maxAge)Prop_age[iage]=Prop_age[iage-1]*Surv_age[iage-1]
Prop_age <- Prop_age/sum(Prop_age)  #stable age distribution
survCurv <- Prop_age #Sets probability of founder cohort belonging to each age class

#Set parameters for altMate
batchsize = 6 #average size of brood -- assumes Poisson distribution for fecundity (which is default for altMate)
mat_m <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_m[12:maxAge]=1  #Knife-edge maturity for males, beginning at age 12

mat_f <- rep(0,maxAge) #creates an empty vector that has the length of n_ages
mat_f[13:maxAge]=1  #Knife-edge maturity for females, beginning at age 13

maleCurve <- mat_m #Set male age at maturity
femaleCurve <- mat_f #Set female age at maturity
maxClutch <- 18 #Maximum number of offspring one individual can possibly produce
ageMort <- c(.15, rep(.05, 1000))
```

###Make Founder population and simulate into the future
```{r}
#makeFounders creates a matrix of specified size (pop) where each row is an individual in the founder popualtion.
indiv <- makeFounders(pop = 9000, osr = c(0.56, 0.44), stocks = c(1), maxAge = 40, survCurv=Prop_age)
head(indiv)
colnames(indiv) <- c("ID", "Sex", "Father.ID", "Mother.ID", "Birth.Year", "Death.Year", "Stock", "Age", "col_x") #unsure what column 9 is ...
hist(as.numeric(indiv[,8])) #histogram of population ages

#Simulate 100 years of mating
#altMate derives the number of offspring produced by drawing from a sampling distribution for each female based on the parameters specified in the function. Fathers are randomly drawn from all mature males in the mother's stock.
##This loop takes ~ 1 minute to run
sim_yrs = c(1:100)
for (y in 1:length(sim_yrs)) {
  indiv <- altMate(indiv, batchSize = batchSize, fecundityDist = "poisson", year = y, type = "ageSex", maxClutch = maxClutch, singlePaternity = FALSE, maleCurve = maleCurve, femaleCurve = femaleCurve)
  indiv <- mort(indiv, type = "simple", maxPop = 9000, year=y, maxAge = 40) #make maxPop ~ 9000 if setting mort to flat, as this is the approx size of the population in the Bravington script.
  indiv <- birthdays(indiv)
}

nrow(indiv[is.na(indiv[,6]),]) ## the currently-alive population size.
```

Find out how many adults are alive at t0 to compare to model estimates
```{r}
ncol(indiv)
indiv2 <- as.data.frame(indiv)
indiv2 <- indiv2[!is.na(indiv2$Death.Year),]

# Number of mature females alive at t0
cat(paste("Females alive at t0:", sum(as.numeric(as.character(indiv2$Age)) > as.numeric(as.character(indiv2$Death.Year)) & indiv2$Sex=="F")))

# Number of mature males alive at t0
cat(paste("Males alive at t0:", sum(as.numeric(as.character(indiv2$Age)) > as.numeric(as.character(indiv2$Death.Year)) & indiv2$Sex=="M")))
tail(indiv2)
```

### Sampling
Simulates six more years of population growth, sampling 100 individuals each year. Grabs the birth year and sex of each individual from the indiv table, then manually gives a death year that corresponds to the year of sampling.
```{r}
n_samp_yr = t_end-t_start #Number of years being sampled
n_samples_per_yr = 100
sample_vec <- c()
death_yr <- c()
#Repeats the above loop, assigning offspring, deaths, and birthdays, but this time also draws samples each year
for (y in c(t_start:t_end)) {
  indiv <- altMate(indiv, batchSize = .5, firstBreed = 0, fecundityDist = "binomial", year = y, type = "age", maxClutch = 1, singlePaternity = TRUE, maturityCurve = c(rep(0,6), 0.1666667, 0.3333333, 0.5, 0.6666667, 0.8333333, rep(1.0, 1000)))
  indiv <- mort(indiv, type = "simple", maxPop = 9000, year=y, maxAge = 40)
  indiv <- birthdays(indiv)
  sample_vec <- append(sample_vec, sample(indiv[indiv[,5] > (y-n_ages) & is.na(indiv[,6]) == TRUE,][,1], size = n_samples_per_yr))
  death_yr <- append(death_yr, rep(y, n_samples_per_yr))
}

length(sample_vec)
length(death_yr)
sampled <- cbind(sample_vec,death_yr) #make dataframe of sampled individuals and death year
sampled <- data.frame(sampled[duplicated(sampled[,1])==FALSE,]) #get rid of duplicate values

#Compare sampled individuals to population matrix and pull birth year and sex into sampled matrix
for(i in 1:length(sampled[,1])) {
  sampled[i,3] = as.numeric(indiv[which(indiv[,1] == sampled[i,1]),5]) #birth year
  sampled[i,4] = indiv[which(indiv[,1] == sampled[i,1]),2] #sex
}


colnames(sampled) <- c("ID", "Death Year", "Birth Year", "Sex")
length(sampled[,1])
sampled <- sampled[,c(1,3,2,4)] #not sure why this is here?
head(sampled)
tail(sampled)

#assign numeric sex to new column in sampled
sexnum <- c()
for(i in 1:length(sampled[,1])) {
  if(sampled[i,4] == "F") sexnum[i] = 0 else sexnum[i] = 1
}
sampled$sexnum <- sexnum
head(sampled)
tail(sampled)
```

###CKMR script
##Define variables and functions
```{r}
source("functions/get_P_beluga_sim.R")
source("functions/beluga_neg_log_like_sim.R")

n_yrs=t_end
P_Mother = P_Father = array(0,dim=c(n_yrs,n_yrs,n_yrs))
P = get_P_beluga(Pars=Pars,P_Mother=P_Mother,P_Father=P_Father,Maturity_age=Maturity_age,n_yrs=n_yrs,t_start=t_start,t_end=t_end)

#Check P function
P$P_Mother[89,101,100] #mother born in year 89, died in year 101, gave birth to offspring in year 100
```

Find relatives among sampled individuals
```{r}
## Find relatives among sampled individuals
## findRelativesPar finds relatives among the sampled individuals and stores them in a massive pairwise comparison dataframe where the columns are named with numeric code corresponding to the relationships shared between the individuals being compared.
pairs <- findRelativesPar(indiv = indiv, sampled = sampled[,1])

HSPs <- pairs[pairs$TwoTwo == 1,] ##pairs that are half-siblings of each other
POPs <- pairs[pairs$OneTwo == 1,] ##pairs that are parents of each other
head(POPs)

POPs2 <- POPs[,1:2] #extract IDs from related individuals (for use in the next chunk)
length(POPs2[,1])
head(POPs2)

non_POPs <- pairs[pairs$OneTwo == 0,] ##pairs that are not related
non_POPs2 <- non_POPs[,1:2] #extract IDs from unrelated individuals (for use in the next chunk)
```

##Extract information for CKMR model
```{r}
#Related individuals
Data2 <- matrix(0, nrow = length(POPs2[,1]), ncol = 5)

#The For loop will return an error unless POPs2 and sampled have the same factor levels
POPs2[,1] <- factor(POPs2[,1], levels=levels(sampled[,1]))
POPs2[,2] <- factor(POPs2[,2], levels=levels(sampled[,1]))

for(i in 1:length(POPs2[,1])) { #extract data for CKMR for POPs from sampled individuals by comparing indiv IDs
  if(sampled[which(sampled[,1]==POPs2[i,1]),2] < sampled[which(sampled[,1]==POPs2[i,2]),2]) {
  Data2[i,1] = sampled[which(sampled[,1]==POPs2[i,1]),2]
  Data2[i,2] = sampled[which(sampled[,1]==POPs2[i,1]),3]
  Data2[i,3] = sampled[which(sampled[,1]==POPs2[i,2]),2]
  Data2[i,4] = sampled[which(sampled[,1]==POPs2[i,1]),5] #column 5 is numeric sex
  } else if(sampled[which(sampled[,1]==POPs2[i,1]),2] > sampled[which(sampled[,1]==POPs2[i,2]),2]) {
  Data2[i,1] = sampled[which(sampled[,1]==POPs2[i,2]),2]
  Data2[i,2] = sampled[which(sampled[,1]==POPs2[i,2]),3]
  Data2[i,3] = sampled[which(sampled[,1]==POPs2[i,1]),2]
  Data2[i,4] = sampled[which(sampled[,1]==POPs2[i,2]),5]
  }
}

head(Data2,12)
tail(Data2)
Data2[,2] <- Data2[,2] + 100

######Unrelated individuals######
Data3 <- matrix(0, nrow = length(non_POPs2[,1]), ncol = 5)

#The For loop will return an error unless non_POPs2 and sampled have the same factor levels
non_POPs2[,1] <- factor(non_POPs2[,1], levels=levels(sampled[,1]))
non_POPs2[,2] <- factor(non_POPs2[,2], levels=levels(sampled[,1]))

#extract data for CKMR for unrelated pairs from sampled individuals by comparing indiv IDs and the corresponding ages to determine which should be the parent and which the offspring. Intra-cohort samples (i.e. same age) are just included in the second half of the loop.

#Is it possible to parallelize the below loop? It takes forever ... 

for(i in 1:length(non_POPs2[,1])) {
  if(sampled[which(sampled[,1]==non_POPs2[i,1]),2] < sampled[which(sampled[,1]==non_POPs2[i,2]),2]) {
  Data3[i,1] = sampled[which(sampled[,1]==non_POPs2[i,1]),2]
  Data3[i,2] = sampled[which(sampled[,1]==non_POPs2[i,1]),3]
  Data3[i,3] = sampled[which(sampled[,1]==non_POPs2[i,2]),2]
  Data3[i,4] = sampled[which(sampled[,1]==non_POPs2[i,1]),5] #column 5 is numeric sex
  } else if(sampled[which(sampled[,1]==non_POPs2[i,1]),2] > sampled[which(sampled[,1]==non_POPs2[i,2]),2] | sampled[which(sampled[,1]==non_POPs2[i,1]),2] == sampled[which(sampled[,1]==non_POPs2[i,2]),2]) {
  Data3[i,1] = sampled[which(sampled[,1]==non_POPs2[i,2]),2]
  Data3[i,2] = sampled[which(sampled[,1]==non_POPs2[i,2]),3]
  Data3[i,3] = sampled[which(sampled[,1]==non_POPs2[i,1]),2]
  Data3[i,4] = sampled[which(sampled[,1]==non_POPs2[i,2]),5]
  }
}

head(sampled)
head(Data3,12)
Data3[,2] <- Data3[,2] + 100
tail(Data3)
length(Data3[,1]) #Should be same as non_POPs2
length(non_POPs2[,1])
```

```{r}
#subset from Data columns 1:4 of the rows that meet the criteria of sex being father and probability of kinship being 0
#Data_dad_no[,1] = adult birth,
#Data_dad_no[,2] = adult death year
#Data_dad_no[,3] = young birth
#Data_dad_no[,4] = adult sex
Mom_POPs = data.frame(Data2[which(Data2[,4]==0),1:3])
Dad_POPs = data.frame(Data2[which(Data2[,4]==1),1:3])
Mom_nonPOPs = data.frame(Data3[which(Data3[,4]==0),1:3])
Dad_nonPOPs = data.frame(Data3[which(Data3[,4]==1),1:3])
colnames(Mom_POPs) = colnames(Dad_POPs) = colnames(Mom_nonPOPs) = colnames(Dad_nonPOPs) = c("parent birth", "parent death", "offspring birth")

length(Data3[,1]) 
sum(length(Mom_nonPOPs[,1]),length(Dad_nonPOPs[,1])) #should add up to previous line

length(which(Mom_nonPOPs[,3]==0)) #hopefully zero
length(which(Dad_nonPOPs[,3]==0))
length(which(Data3[,3]==0))

head(Data3)
head(Dad_nonPOPs)

class(Mom_POPs[,1])
class(Dad_POPs[,1]) #double-check that it's numeric

Dad_POPs=count(Dad_POPs[,1:3])
Mom_POPs=count(Mom_POPs[,1:3])
Dad_nonPOPs=count(Dad_nonPOPs[,1:3])
Mom_nonPOPs=count(Mom_nonPOPs[,1:3])

head(Dad_POPs)
head(Mom_POPs)
head(Dad_nonPOPs)
tail(Dad_nonPOPs)

#Save dataframes as the names that the CKMR model uses
Data_dad_no = Dad_nonPOPs
Data_dad_yes = Dad_POPs #same as above except prob kinship is 1
Data_mom_no = Mom_nonPOPs
Data_mom_yes = Mom_POPs
```

Fit model!
```{r}
CK_fit <- optimx(par=Pars,fn=beluga_neg_log_lik,hessian=TRUE,method="BFGS",Negatives_Mother=Data_mom_no,Negatives_Father=Data_dad_no,Pairs_Mother=Data_mom_yes,Pairs_Father=Data_dad_yes,P_Mother=P_Mother,P_Father=P_Father,Maturity_age=Maturity_age,n_yrs=n_yrs,t_start=t_start,t_end=t_end)

CK_fit
save.image(file="CKMR_Sim2.RData") #When making this script into a loop, will need to change this to rename with each separate iteration

#compute variance covariance matrix 
D=diag(4)*c(exp(CK_fit$p1),exp(CK_fit$p2),n_ages*exp(CK_fit$p3)/(1+exp(CK_fit$p3))^2,0.01*exp(CK_fit$p4)/(1+exp(CK_fit$p4))^2) #derivatives of transformations
VC_trans = solve(attr(CK_fit, "details")["BFGS" ,"nhatend"][[1]])
VC = (t(D)%*%VC_trans%*%D) #delta method
SE=sqrt(diag(VC))
cat(paste("Estimated mature female abundance: ",exp(CK_fit$p1),", SE = ",SE[1],"\n"))
cat(paste("Estimated mature male abundance: ",exp(CK_fit$p2),", SE = ",SE[2],"\n"))
cat(paste("Estimated male age at maturity: ",n_ages*plogis(CK_fit$p3),", SE = ",SE[3],"\n"))
cat(paste("Estimated log-scale trend: ",0.01*plogis(CK_fit$p4)-0.005,", SE = ",SE[4],"\n"))
cat(paste("Real scale lambda: ",exp(0.01*plogis(CK_fit$p4)-0.005),"\n"))
```

### Reference/helpful scripts ###
## What's my population doing?
# `check_growthrate()` tells you how quickly your population is growing. `PoNG()` tells you what you need first-year survival to be, in order for your population to maintain a constant size

```{r}
#check_growthrate(mateType = "age", mortType = "age", ageMort = ageMort, batchSize = .209, firstBreed = 0, maxClutch = 1, maturityCurve = c(rep(0,6), 0.1666667, 0.3333333, 0.5, 0.6666667, 0.8333333, rep(1.0, 1000))) #These values may produce a stable population

#PoNG(mateType = "flat", mortType = "age", ageMort = ageMort, batchSize = 8, firstBreed = 12, maxClutch = 18)
```


Look up true relationships - not using right now
```{r}
## look at the number of shared ancestors at each ancestral
## generation, for one of the parent-offspring pairs.
pairs
(lookAtPair(POPs[1,]))

relatives <- namedRelatives(pairs) ## shows the number of pairs of each relationship type
relatives
#Set up Yes and No parentage matrices
```
